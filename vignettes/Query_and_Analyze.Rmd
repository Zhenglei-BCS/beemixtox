---
title: "Query_and_Analyze"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Query_and_Analyze}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval=F
)
library(tidyverse)
library(kableExtra)
```

```{r setup}
library(beemixtox)
```



Search parameters (you must select at least one parameter):
- All Chemicals (Chemical names, CAS Registry numbers or
predefined groups)
- All Effects (Search specific measurements or select major effect
groups from a predefined list)
- All Endpoints (Select all or any endpoints, or statistics but no
endpoint or endpoint is not reported)
- All Species (Select taxonomic kingdom, scientific or common
names, or predefined groups)
- All Test Conditions (Select any or all lab/field studies, exposure
or control media and types, and chemical analysis methods)
- All Publication Options (Search by year, author, datasets or
specific ECOTOX data updates)


The following Query filter options and associated data are available(refine data to select one or more names ) or selecting to include/exclude Aquatic or Terrestrial habitats. 

- Chemicals
- Species Group
- Class
- Order
- Family
- Genus
- Species
- Special Interest Groups
- Effect Groups
- Effect Measurements
- Endpoints
- Publication Years


## Get the data

- From Ismael

```

** Chemicals **


** Effect Measurements **
Mortality Group
	Mortality

** Endpoints **

concentration Based Endpoints
	LD50

** Species **

Name(s) / Number(s)
	honey bee

Kingdom: Animals

Name Search Type: Common Name

** Test Conditions **
Test Locations
	Lab

** Publication Options **

```


- start the connection

```{r}
# db server details
require(RPostgreSQL)
DBname <- 'ecotox'
DBhost <- 'localhost'   # or localhost)
DBport <- '5432' # default is 5432
DBuser <- 'zhenglei_gao'  ## pa$$123a
library(getPass)
drv <- dbDriver("PostgreSQL")
con <- dbConnect(drv, dbname=DBname, user=DBuser, host=DBhost, port=DBport,
                    password = getPass("Enter Password:"))
```


```{r}
dbGetQuery(con,"
SELECT
    tablename,
    indexname,
    indexdef
FROM
    pg_indexes
WHERE
    schemaname = 'ecotox'
ORDER BY
    tablename,
    indexname;")
```

- look for all bees

A note on schema:

Your need to specify the schema.

The query listing all the tables does not consider the schema. To be able to "see" the table in a query, you either need to add its schema to your path, or to specify the schema in your query.

`DBI::dbGetQuery(con,"SELECT * from myschema.analysis")`

If you don't know the schema names, you can run

`dbGetQuery(db,"SELECT table_schema, table_name FROM information_schema.tables")`

```{r}
dbGetQuery(con,"SELECT table_schema, table_name FROM information_schema.tables LIMIT 10")

dbGetQuery(con,"SELECT table_schema, table_name FROM information_schema.tables WHERE table_schema=\'ecotox\' LIMIT 100")

dbGetQuery(con,"SELECT * from ecotox.endpoint_codes LIMIT 5") ## look at the species table
dbGetQuery(con,"SELECT * from ecotox.species LIMIT 10") ## look at the species table

```

It is also possible to connect via dplyr.

- https://win-vector.com/2016/02/01/using-postgresql-in-r/

```{r eval=FALSE}
library('dplyr')

# Connect to local PostgreSQL via dplyr
localdb <- src_postgres(dbname = 'ecotox',
                           host = 'localhost',
                           port = 5432,
                           user = 'zhenglei_gao',
                           password = 'pa$$123a')

## cheat and access the db connection directly
## assume we have made the colnames db safe
## dbWriteTable(localdb$con,'iris',iris, row.names=FALSE)

# this is not a data frame; it's a dplyr PostgreSQL handle into the database
d = tbl(localdb, "ecotox.endpoints_codes") 
d

# this is a data frame
dtab = as.data.frame(d)

# send a query through dplyr
# query = "select avg(sepal_length) avg_sepal_length, 
#                 species 
#          from iris
#          group by species"
# dsub = tbl(localdb, sql(query))
# dsub

## Source: postgres 9.5.0 [ninazumel@localhost:5432/ninazumel]
## From:  [?? x 2]
## 
##    avg_sepal_length    species
## 1             5.936 versicolor
## 2             6.588  virginica
## 3             5.006     setosa
## ..              ...        ...

# # make it local
# dsub = as.data.frame(dsub)
# summary(dsub)

##  avg_sepal_length   species         
##  Min.   :5.006    Length:3          
##  1st Qu.:5.471    Class :character  
##  Median :5.936    Mode  :character  
##  Mean   :5.843                      
##  3rd Qu.:6.262                      
##  Max.   :6.588

# shuts down database
rm(list=c('d','localdb')); gc() 

```



- select species including bees and get the endpoints. 


```{r}
dbGetQuery(con,"SELECT * FROM ecotox.species WHERE common_name  = \'Fathead Minnow\'")
dbGetQuery(con,"SELECT * FROM ecotox.species WHERE common_name  = \'Honey Bee\'")

## get where the string of bee is inlcuded?
# dbGetQuery(con,"SELECT * FROM ecotox.species WHERE strpos(\'Bee\' in \'common_name\')>0")  ## why doesn't this way work?
dbGetQuery(con,"SELECT species_number, common_name FROM ecotox.species WHERE position(\'Bee\' in common_name)>0 LIMIT 10")  ## 
sps <- dbGetQuery(con,"SELECT species_number, common_name, ecotox_group FROM ecotox.species WHERE common_name ILIKE '%bee%' AND common_name NOT ILIKE '%beet%' AND common_name NOT ILIKE '%beetle%' AND common_name NOT ILIKE '%beec%' AND common_name NOT ILIKE '%beeplant%' AND common_name NOT ILIKE '%beeb%' AND common_name NOT ILIKE '%lice%' AND common_name NOT ILIKE '%beef%' AND common_name NOT ILIKE '%bee-%' AND common_name NOT ILIKE '%mite%' AND common_name NOT ILIKE '%spiderflower%' AND common_name NOT ILIKE '%moth%' AND common_name NOT ILIKE '%Flies%' AND common_name NOT ILIKE '%beer%' AND common_name NOT ILIKE '%bee orchid%' AND common_name NOT ILIKE '%fish%'")


sps <- dbGetQuery(con,"SELECT species_number, common_name, ecotox_group FROM ecotox.species WHERE common_name ILIKE '%honey bee%' or common_name ILIKE '%honeybee%'")

sps %>% kable(., format = "html") %>% kable_styling(bootstrap_options = c("striped", "hover"), full_width = F, fixed_thead = T, position = "left")
##  LEFT JOIN ecotox.results on 


names(dbGetQuery(con,"SELECT * FROM ecotox.tests LIMIT 1"))

tests1 <- dbGetQuery(con,
"SELECT 
          species_number, test_id,reference_number, test_cas, test_type,test_grade,test_formulation,exposure_type,organism_lifestage, organism_age_mean,organism_age_unit, exposure_duration_mean,exposure_duration_unit, test_location
FROM 
          ecotox.tests 
LEFT JOIN ecotox.species i USING (species_number)
WHERE 
          common_name ILIKE '%honey bee%' OR common_name ILIKE '%honeybee%'
ORDER BY test_cas
")

## TRY to Understand the resulting differences in LEFT JOIN and RIGHT JOIN
# tests2 <- dbGetQuery(con,
# "SELECT 
#           species_number, test_id,test_cas,test_grade,test_formulation
# FROM 
#           ecotox.tests 
# RIGHT JOIN ecotox.species i USING (species_number)
# WHERE 
#           common_name ILIKE '%bee%' AND common_name NOT ILIKE '%beet%' AND common_name NOT ILIKE '%beetle%' AND common_name NOT ILIKE '%beec%' AND common_name NOT ILIKE '%beeplant%' AND common_name NOT ILIKE '%beeb%' AND common_name NOT ILIKE '%lice%' AND common_name NOT ILIKE '%beef%' AND common_name NOT ILIKE '%bee-%' AND common_name NOT ILIKE '%mite%' AND common_name NOT ILIKE '%spiderflower%' AND common_name NOT ILIKE '%moth%' AND common_name NOT ILIKE '%Flies%' AND common_name NOT ILIKE '%beer%' AND common_name NOT ILIKE '%bee orchid%' AND common_name NOT ILIKE '%fish%'
# ORDER BY test_cas
# ")
# 
# 
# 
# all(tests1$species_number %in% tests2$species_number)
# unique(tests2$species_number[which(!(tests2$species_number %in% tests1$species_number))])
# 
# sps$common_name[sps$species_number %in% unique(tests2$species_number[which(!(tests2$species_number %in% tests1$species_number))])]
# 
# tests2[which(!(tests2$species_number %in% tests1$species_number)),]


resnames <- dbGetQuery(con,"SELECT * FROM ecotox.results WHERE endpoint ILIKE '%LC50%' OR endpoint ILIKE '%LD50%' LIMIT 1")

results <- dbGetQuery(con,"SELECT result_id, test_id, endpoint, effect, obs_duration_mean_op,obs_duration_mean, obs_duration_unit, conc1_mean_op, conc1_mean, conc1_unit, conc1_type FROM ecotox.results WHERE endpoint ILIKE '%LC50%' OR endpoint ILIKE '%LD50%'")

results <- left_join(tests1,results,by="test_id")
results <- left_join(results,sps,by="species_number")
dim(results) ## 6742*25
# It is all insects
# ecotox_group_convert <- dbGetQuery(con,"SELECT * FROM ecotox.ecotox_group_convert")
# left_join(sps,ecotox_group_convert)

chem <- dbGetQuery(con,"SELECT * FROM ecotox.chemicals")

bees <- left_join(results,chem,by=c("test_cas"="cas_number"))
## only mortality
bees <- bees%>%filter(effect=="MOR") %>% filter(endpoint=="LD50" | endpoint=="LD50/") 
bees <- bees%>%filter(organism_lifestage %in% c("AD")) ## only adult endpoints
```



```{r WrongJoin,eval=F}
unit_convert <- dbGetQuery(con,"SELECT * FROM ecotox.unit_convert")
## This is where it goes wrong, the unit_convert table does not contain all the necessary unit
bees <- left_join(results,unit_convert,by=c("conc1_unit"="unit"))
bees <- bees %>% mutate(conc1=as.numeric(conc1_mean)*multiplier) %>% mutate(conc1_unit_conv=unit_conv) %>% dplyr::select(-c(convert,unit_conv))

duration_convert <- dbGetQuery(con,"SELECT * FROM ecotox.duration_convert")
bees <- left_join(bees,duration_convert,by=c("obs_duration_mean"="duration", "obs_duration_unit"="unit"))
bees <- bees %>%  mutate(duration_unit_conv=unit_conv) %>% dplyr::select(-c(convert,unit_conv))
dbGetQuery(con,"SELECT * FROM ecotox.chemical_carriers LIMIT 10")

chem <- dbGetQuery(con,"SELECT * FROM ecotox.chemicals")
chem1 <- dbGetQuery(con,"SELECT * FROM ecotox.chemical_carriers")
tmp <- left_join(chem,chem1,by=c("cas_number"="cas_number"))
sum(tmp$chemical_name==tmp$chem_name,na.rm=T)
# > sum(tmp$chemical_name==tmp$chem_name,na.rm=T)
# [1] 175793
# > dim(tmp)
# [1] 192265     21
# > 
sum(tmp$chemical_name==tmp$chem_name,na.rm=T)



sum(is.na(tmp$chemical_name))
nrow(tmp)-sum(is.na(tmp$chem_name))

bees <- left_join(bees,chem,by=c("test_cas"="cas_number"))
## only mortality
bees <- bees%>%filter(effect=="MOR") %>% filter(endpoint=="LD50" | endpoint=="LD50/") 
bees <- bees%>%filter(organism_lifestage %in% c("AD")) ## only adult endpoints

sum(Data.1$CAS.Number %in% bees$test_cas)
sum(Data.1$Reference.Number %in% bees$reference_number)
sum(Data.1$Conc.1.Mean..Author. %in% bees$conc1_mean)
```


- add unit conversion

```{r eval=F}
beeunits2 <- c("AI mg/org","AI ng/org","AI ug/org","mg/bee","mg/org","ng/org","ug/bee","ug/org","ug/org/d")

bees <- bees %>% filter(conc1_unit %in% beeunits2)
## check consistency with Ismael's downloaded dataset.
sum(Data.1$CAS.Number %in% bees2$test_cas)
sum(Data.1$Reference.Number %in% bees2$reference_number)
sum(as.numeric(Data.1$Conc.1.Mean..Author.) %in%  as.numeric(bees$conc1_mean))

beemultiplier <- c(1000,1/1000,1,1000,1000,1/1000,1,1,1)

multiplier <- plyr::mapvalues(bees$conc1_unit,from=beeunits2,to=beemultiplier)
bees <- bees %>% mutate(conc1=as.numeric(conc1_mean)*multiplier)

```

```{r wrongBeeunits,eval=FALSE}
beeunits <- c("mg/org","ug/org","ng/org","pg/org","ug/org/d")
beemultiplier <- c(1000,1,0.001,1e-06,1)

bees1 <- bees %>% filter(conc1_unit_conv %in% beeunits) 

multiplier <- plyr::mapvalues(bees$conc1_unit_conv,from=beeunits,to=beemultiplier)
bees1 <- bees %>% mutate(conc1=conc1*multiplier)

sum(Data.1$CAS.Number %in% bees$test_cas)
sum(Data.1$Reference.Number %in% bees$reference_number)
```


- add duration conversion 
Restrict to exposure time between 1 day to 2 days

```{r}
durationUnits <- c("h",  "em", "wk", "d",  "mi")
durationMultiplier <- c(1,NA,7*24,24,1/60)
multiplier <- plyr::mapvalues(bees$obs_duration_unit,from=durationUnits,to=durationMultiplier)
bees1 <- bees %>% mutate(duration_conv=as.numeric(obs_duration_mean)) %>% mutate(duration_conv=duration_conv*as.numeric(multiplier)) %>% filter(duration_conv <= 48 & duration_conv>=24)
## check consistency with Ismael's downloaded dataset.
sum(Data.1$CAS.Number %in% bees1$test_cas)
sum(Data.1$Reference.Number %in% bees1$reference_number)
sum(as.numeric(Data.1$Conc.1.Mean..Author.) %in%  as.numeric(bees1$conc1_mean))
bees <- bees1

sum(Data.1$CAS.Number %in% bees$test_cas)
sum(Data.1$Reference.Number %in% bees$reference_number)
sum(as.numeric(Data.1$Conc.1.Mean..Author.) %in%  as.numeric(bees$conc1_mean))
```



```{r wrongDurationUnites,eval=F}
durationUnits <- c("h",  "mi","d",NA)
durationMultiplier <- c(1,1/60,24,1)
multiplier <- plyr::mapvalues(bees$duration_unit_conv,from=durationUnits,to=durationMultiplier)
bees1 <- bees %>% mutate(duration_conv=as.numeric(duration_conv)) %>% mutate(duration_conv=duration_conv*multiplier) %>% filter(duration_conv <= 48 & duration_conv>=24)
```


- Restrict Exposure type in just Oral via capsule and Spray

## ?? 

```{r}
bees1 <- bees %>% filter(exposure_type=="OR"| exposure_type=="SP")
## check consistency with Ismael's downloaded dataset.
sum(Data.1$CAS.Number %in% bees1$test_cas)
sum(Data.1$Reference.Number %in% bees1$reference_number)
sum(as.numeric(Data.1$Conc.1.Mean..Author.) %in%  as.numeric(bees1$conc1_mean))

```



```{r}
usethis::use_data(bees,overwrite = T)
```


```{r}
tmp <- bees %>% filter(!is.na(conc1))

table(tmp$exposure_type,useNA = c("ifany")) %>%  kable(., format = "html") %>% kable_styling(bootstrap_options = c("striped", "hover"), full_width = F, fixed_thead = T, position = "left")

table(tmp$test_location,useNA = c("ifany")) %>%  kable(., format = "html") %>% kable_styling(bootstrap_options = c("striped", "hover"), full_width = F, fixed_thead = T, position = "left")

table(tmp$conc1_unit_conv,useNA = c("ifany")) %>%  kable(., format = "html") %>% kable_styling(bootstrap_options = c("striped", "hover"), full_width = F, fixed_thead = T, position = "left")

table(tmp$conc1_type) %>%  kable(., format = "html") %>% kable_styling(bootstrap_options = c("striped", "hover"), full_width = F, fixed_thead = T, position = "left")

table(tmp$duration_conv,useNA = c("ifany")) %>%  kable(., format = "html") %>% kable_styling(bootstrap_options = c("striped", "hover"), full_width = F, fixed_thead = T, position = "left")

table(tmp$exposure_type,useNA = c("ifany")) %>%  kable(., format = "markdown")

table(tmp$test_type,useNA = c("ifany")) %>%  kable(., format = "markdown")


table(paste("study duration:",tmp$duration_conv,tmp$duration_unit_conv,"; exposure duration:",tmp$exposure_duration_mean,tmp$exposure_duration_unit,"; exposure type:",tmp$exposure_type,"; species: ",tmp$common_name),useNA = c("ifany")) %>%  kable(., format = "html") %>% kable_styling(bootstrap_options = c("striped", "hover"), full_width = F, fixed_thead = T, position = "left")

# left_join(sps,ecotox_group_convert)

## save(results,file="~/Projects/beemixtox/data/bees.rda")
```


## Close DB connection

```{r}

dbDisconnect(con)
dbUnloadDriver(drv)
```



## Do the work

1.	Downloading and curating bee acute end-points (acute oral and acute contact bee LD50s) form the ECOTOX Knowledge base for as much chemicals as possible.
2.	Restrict the database for chemicals with repeated entries (i.e., more than 3 or 5 LD50 for the same chemical)

```{r}
bee1 <- bees %>% filter(!is.na(conc1)) %>% filter(test_type=="ACUTE")
bee1%>% group_by(chemical_name) %>% summarise(n=length(chemical_name))%>%  kable(., format = "html") %>% kable_styling(bootstrap_options = c("striped", "hover"), full_width = F, fixed_thead = T, position = "left")
## Restrict the database for chemicals with repeated entries (i.e., more than 3 or 5 LD50 for the same chemical)
tmp <- bee1%>% group_by(chemical_name) %>% summarise(n=length(chemical_name))%>% filter(n>3)

bee1 <- bee1 %>% filter(chemical_name %in% tmp$chemical_name)
dim(bee1)
```


3.	Calculate the CV% of the LD50s per chemical, and compute summary statistics (median CV% and 95% CI for CV%) that are typical for these types of bee studies

- https://influentialpoints.com/Training/confidence_interval-of-coefficient_of_variation.htm
- https://math.stackexchange.com/questions/2132334/confidence-interval-and-variance-of-coefficient-of-variation
- https://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/coefvacl.htm

### Naive method

$$\mbox{lcl} =
           \frac{s}{\bar{x}} \sqrt{\frac{n-1}{\chi^{2}_{(1-\alpha/2;n-1)}}}$$
$$\mbox{ucl} =
           \frac{s}{\bar{x}} \sqrt{\frac{n-1}{\chi^{2}_{(\alpha/2;n-1)}}}$$
           
### McKay confidence limit

$$
\mbox{lcl} = \frac{K}
              {\sqrt{\left( \frac{u_1}{n} - 1 \right) K^2 + \frac{u_1}{n-1}}}
$$

$$
\mbox{ucl} = \frac{K}
              {\sqrt{\left( \frac{u_2}{n} - 1 \right) K^2 + \frac{u_2}{n-1}}}
$$
where, $u_1 = \chi^2_{1 - \alpha/2,n-1}, u_2 = \chi^2_{\alpha/2,n-1}$

Note that if the coefficient of variation is greater than 0.33, either the normality of the data is suspect or the probability of negative values in the data is non-neglible. In this case, McKay's approximation may not be valid. Also, it is generally recommended that the sample size should be at least 10 before using McKay's approximation.

### Vangel proposed the following modification to McKay's method.

$$
\mbox{lcl} = \frac{K}
              {\sqrt{\left( \frac{u_1 + 2}{n} - 1 \right)
               K^2 + \frac{u_1}{n-1}}}
$$
$$
\mbox{ucl} = \frac{K}
              {\sqrt{\left( \frac{u_2 + 2}{n} - 1 \right)
              K^2 + \frac{u_2}{n-1}}}
$$
In general, the Vangel's modified McKay method is recommended over the McKay method. It generally provides good approximations as long as the data is approximately normal and the coefficient of variation is less than 0.33.


### Lognormal distribution

$$
\mbox{lcl} = \sqrt{\exp(a_L) - 1}
$$


$$
\mbox{lcl} = \sqrt{\exp(a_U) - 1}
$$

where, $a_L=\frac{(n-1)S_{n}^{2}} {\chi_{n-1,1-\alpha/2}}, a_U=\frac{(n-1)S_{n}^{2}} {\chi_{n-1,1-\alpha/2}}$, $S_{n}^2$ = the variance of the log of the data. 




```{r}
bee1 %>% group_by(chemical_name) %>% summarise(mu=mean(conc1),sigma=sd(conc1),cv=sigma/mu,N=length(chemical_name),S2=var(log(conc1))) %>% mutate(L=qchisq(0.025,N-1),U=qchisq(0.975,N-1),K=cv)%>%mutate (CIL=1/sqrt(U*(1-K^2)/100/K^2),CIU=1/sqrt(L*(1-K^2)/100/K^2))%>% mutate(se_cv=cv*(1+1/4/N)/sqrt(2*N),cvL=cv-1.96*se_cv,cvU=cv+1.96*se_cv) %>% mutate(aL=(N-1)*S2/U,aU=(N-1)*S2/L,lcl=sqrt(exp(aL)-1),ucl=sqrt(exp(aU)-1)) %>% dplyr::select(-c(L,U,K,CIL,CIU,S2,aL,aU)) %>% kable(.,"markdown",digits = 3)
```


4.	Perform simulations as in Belden and Brain to determine the 95th of MCR values that reject the Null Hypothesis that the MCR values is greater than 1 under 2 or three CV% scenarios based on results from point 3.

- assumed a log-normal distribution based on specific CV value and randomly generated effective concentrations for theoretical active ingredients and a formulation mixture centered around a "true" value of 1 (12 000 iterations).
    - For example, for a binary mixture AB, a value would be generated for compound A, compound B, and mixture AB.  Each value was generated assuming a mean value 1.  
- For each iteration, an MDR was calculated. 
- The distribution of the resulting MDR values was then determined
- We repeated this process for CVs of 60%, 100%, and 140%.
- We also conducted the analysis for single, binary, and tertiary
mixtures.

```{r}


```

